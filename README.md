# Tenzies

### Skills: and Technologies used
Basic Web Design and layout: HTML, CSS, Figma 
JavaScript front-end library: ReactJS
Cloud Storage: Local storage
Built tools: Vite
Runtime Environment: NodeJS
Deployment: Netlify
Code Editor: VSCode, ESLint, Prettier
Version Control: Git, Github

### Creating and rolling the dice component
The dice components were generated using the generateNewDie function which switches between dice numbers with matching dice images. These dice images were then passed down as props to the Die component to be rendered to the UI.

A rollDice function handling the click event was created to generate a random dice and push them into an array, which was then set into React state using useState hook. This function will only roll the dice if the dice is not held by the user.

### Hold clicked dice in place
To hold a dice when the user clicks on it, and to prevent it from rolling again when rollDice is called, a boolean isHeld state is introduced to indicate if a dice is being held or not. For this purpose each dice needs to be uniquely idetified using id numbers generated by nanoid function. A holdDice function was defined for the holdDice click event so when a particular dice is clicked, its ID is passed into the function which then uses the map function to return the identified dice with flipped state.  

### Determining winning state
A React useEffect hook with dependency on dice state is used to determine if a game has been won (10 same dice and all has been held). Upon winning a game, the tenzies state will be set to true which allows for the conditional rendering of confetti for 10 seconds. The conditional rendering of the confetti is also realised using an useEffect with a setTimeout callack and depends on tenzies state.  

### Tracking game time
The best winning time was tracked using a useEffect hook that executes a callback function to set interval to hundredths of milliseconds, which is then set into a state. This state is then processed to render the correct times to the UI.

### Storing fastest winning time
The fastest winning time is stored into local storage. Two useEffect hooks were used here, one for initial rendering of the app, and the other for subsequent renderings. The first hook is used during initial renders, where it determine the best time to display on the UI. It checks if data exists in local storage it will grab it and set in as best time, else it initialise the best time to 0.

The second useEffect hook is for subsequent renderings of the app, that runs every time the gameTime state is set. The callback function executes a comparison of the game winning time and the time stored in local storage to determine the smallest time.


